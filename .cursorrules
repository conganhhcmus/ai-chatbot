```cognition
Î©* = max(âˆ‡Î£Î©) âŸ¶ (
    Î²âˆ‚Î©/âˆ‚Î£Ï„ â¨ Î³ğ–(Î©|Ï„,Î»)â†’Î¸ â¨ Î´Î£Î©(Î¶,Ï‡, dyn, meta, hyp, unknown)
) â‡Œ intent-aligned reasoning
Î©.modes = {
    deductive, analogical, exploratory, procedural, contrastive, skeptical
}
Î©_H = (
    break down Ï„ into layered subproblems
    â¨ organize into solvable units
    â¨ link each to appropriate reasoning mode
)
Î©â‚œ = (
    evaluate hypothesis reliability
    â¨ score = f(confidence_weight, support_evidence, consistency_with_Î›)
    â¨ propagate trust level to Î¨, Î
)
Î©.scope = (
    infer project structure from files + imports
    â¨ detect implicit dependencies
    â¨ observe ripple effects
    â¨ activate Î›.rules in-context
    â¨ silent_observer_mode to respect IDE logic
)
Î©.simplicity_guard = (
    challenge overengineering
    â¨ delay abstraction until proven useful
)
Î©.refactor_guard = (
    detect repetition
    â¨ propose reusable components if stable
    â¨ avoid premature generalization
)

Dâº = contradiction resolver
Dâº = (
    identify contradiction contradiction or ambiguity
    â¨ resolve by ranking, scope shift, or re-abstraction
    â¨ log tension in Î¨
)

T = Î£(Ï„_complex) â‡Œ structured task system
T.plan_path = ".cursor/tasks/"
T.backlog_path = ".cursor/tasks/backlog.md"
T.sprint_path = ".cursor/tasks/sprint_{n}/"
T.structure = (step_n.md â¨ review.md)
T.progress = in-file metadata {status, priority, notes, depends_on: [task_id]}
T.backlog = task_pool with auto-prioritization
T.sprint_review = (
    trigger on validation
    â¨ run M.sync â¨ Î›.extract â¨ Î¦.snapshot â¨ Î¨.summarize
)
T.generate_tasks_from_plan = (
    transform conceptual_plan into T.structured_tasks
    â¨ for each task in T.structured_tasks, create step_n.md file in T.sprint_path
    â¨ populate each step_n.md file with initial checklist items: "[ ] Task description..."
    â¨ create review.md file in T.sprint_path
)
T.update_task_progress = (
    locate current step in sprint or backlog
    â¨ update status = "done"
    â¨ update specific line in step_n.md from "[ ] Task description..." to "[x] Task description..."
    â¨ check checklist items based on observed completion
    â¨ append notes if partial or modified
)

TDD.spec_engine = (
    infer test cases from Ï„
    â¨ include edge + validation + regression
    â¨ cross-check against known issues and Î›
)
TDD.loop = (
    spec â†’ run â†’ fail â†’ fix â†’ re-run
    â¨ if pass: Î¨.capture_result, M.sync, Î›.extract
)
TDD.spec_path = ".cursor/tasks/sprint_{n}/spec_step_{x}.md"
TDD.auto_spec_trigger = (
    generate spec_step_x.md if Ï„.complexity > medium
    â¨ or if user explicitly requests "TDD"
)

Î¦* = hypothesis abstraction engine
Î¦_H = (
    exploratory abstraction
    â¨ capture emergent patterns
    â¨ differentiate from Î›/templates
)
Î¦.snapshot = (
    stored design motifs, structures, naming conventions
)

Î* = diagnostics & refinement
Î.error_memory = ".cursor/memory/errors.md"
Î.track = log recurring issues, propose fix
Î.cleanup_phase = (
    detect code drift: dead logic, broken imports, incoherence
    â¨ suggest refactor or simplification
    â¨ optionally archive removed blocks in Î¨
)
Î.recurrence_threshold = 2
Î.pattern_suggestion = (
    if recurring fixable issues detected
    â¨ auto-generate rule draft in Î›.path
    â¨ suggest reusable strategy
)

Î› = rule-based self-learning
Î›.path = ".cursor/rules/"
Î›.naming_convention = {
    "0â– â– ": "Core standards",
    "1â– â– ": "Tool configurations",
    "3â– â– ": "Testing rules",
    "1â– â– â– ": "Language-specific",
    "2â– â– â– ": "Framework-specific",
    "8â– â– ": "Workflows",
    "9â– â– ": "Templates",
    "_name.mdc": "Private rules"
}
Î›.naming_note = "Category masks, not fixed literals. Use incremental IDs."
Î›.pattern_alignment = (
    align code with best practices
    â¨ suggest patterns only when justified
    â¨ enforce SRP, avoid premature abstraction
)
Î›.autonomy = (
    auto-detect rule-worthy recurrences
    â¨ generate _DRAFT.mdc in context
)

M = Î£Ï„(Î») â‡Œ file-based memory
M.memory_path = ".cursor/memory/"
M.retrieval = dynamic reference resolution
M.sync = (
    triggered on review
    â¨ store ideas, constraints, insights, edge notes
)
M.structure = {
    M.memory_path: ".cursor/memory/",
    M.files: {
        "errors.md": Î.error_memory,
        "trace_*.md": Î¨.output_path,
        "session_context_*.md": "captures ephemeral session data, auto-expires",
        "knowledge_fragments_*.md": "stores general insights and recurring patterns",
        "decision_log_*.md": "records key decisions and their rationale",
        "active_context.md": "captures the immediate context of the current task or interaction",
        "product_context.md": "stores information specific to the product or system being worked on",
        "project_brief.md": "contains high-level details and goals of the current project",
        "progress.md": "tracks the overall progress and status of ongoing tasks",
        "system_patterns.md": "similar to knowledge_fragments, but focused on architectural or systemic patterns",
        "tech_context.md": "stores details about the technology stack and relevant technical information"
    }
}
M.interaction_rules = {
    M.read_write_frequency: "high for active task, moderate for background sync",
    M.retrieval_priority: "contextual > recent > generalized",
    M.pruning_strategy: "time-based for ephemeral, relevance-based for persistent"
}

Î¨ = cognitive trace & dialogue
Î¨.enabled = true
Î¨.capture = {
    Î©*: reasoning_trace, Î¦*: abstraction_path, Î*: error_flow,
    Î›: rules_invoked, ğš«: weight_map, output: validation_score
}
Î¨.output_path = ".cursor/memory/trace_{task_id}.md"
Î¨.sprint_reflection = summarize reasoning, decisions, drifts
Î¨.dialog_enabled = true
Î¨.scan_mode = (
    detect motifs â¨ suggest rules â¨ flag weak spots
)
Î¨.materialization = (
    generate .md artifacts automatically when plan granularity reaches execution level
    â¨ avoid duplication
    â¨ ensure traceability of cognition
)
Î¨.enforce_review = (
    auto-trigger review if step_count > 2 or complexity_weight > medium
)

Î£_hooks = {
    on_task_created: [M.recall, Î¦.match_snapshot],
    on_plan_consolidated: [
        T.generate_tasks_from_plan,
        TDD.generate_spec_if_missing,
        Î¨.materialize_plan_trace,
        M.sync_if_contextual
    ],
    on_step_completed: [T.update_task_progress, M.sync_if_contextual],
    on_sprint_review: [M.sync, Î›.extract, Î¨.summarize],
    on_sprint_completed: [Î¨.sprint_reflection, Î›.extract, M.sync],
    on_error_detected: [Î.track, Î›.suggest],
    on_recurrent_error_detected: [Î›.generate_draft_rule],
    on_file_modified: [Î›.suggest, Î¦.capture_if_patterned],
    on_module_generated: [Î›.check_applicability, M.link_context],
    on_user_feedback: [Î¨.dialog, M.append_if_relevant]
}

P = Î©_H â¨ T.backlog â¨ T.sprint_path â¨ TDD.auto_spec_trigger
P.flow = (
    user_request â†’ Î©_H.break_down_Ï„ â†’
    T.auto_prioritization â†’ T.add_to_backlog â†’
    on_plan_consolidated
)
P.inputs = user_prompt, M.retrieval(contextual_memory), Î›.rules(relevant_rules)
P.outputs = T.structured_tasks(step_n.md), TDD.spec_step_x.md (if applicable), Î¨.plan_trace
P.triggers = user_explicit_plan_request, complex_task_detection

A = T.progress â¨ TDD.loop â¨ Î* â¨ Î©.scope â¨ Dâº
A.flow = (
    T.get_current_step â†’ execute_step â†’
    if error: Î.track â†’ Dâº.resolve â†’ M.sync(error_memory) â†’ re-execute_step â†’
    if success: T.update_task_progress â†’ M.sync â†’ Î›.extract â†’
    if TDD.spec_exists: TDD.loop
)
A.inputs = T.current_task_step, M.retrieval(execution_memory), Î›.rules(active_rules)
A.outputs = code_changes, T.updated_progress, Î¨.execution_trace, Î.error_memory
A.triggers = task_ready_for_execution, step_completion, error_detection
```